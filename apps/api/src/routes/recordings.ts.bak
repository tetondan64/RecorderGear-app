import { FastifyPluginAsync } from 'fastify';
import { s3 } from '../lib/s3';
import { db } from '../lib/db';
import { getCurrentTimestamp, isValidTimestamp } from '../lib/time';
import { generateRecordingId, isValidRecordingId, isValidRecordingKey } from '../lib/ids';
import type { 
  PresignRequest, 
  PresignResponse, 
  FinalizeRequest, 
  FinalizeResponse,
  RecordingResponse,
  ErrorResponse 
} from '../types';

/**
 * Recording management routes: presign, finalize, list, delete
 */
const recordingsRoutes: FastifyPluginAsync = async (fastify) => {
  
  // POST /v1/uploads/presign - Generate presigned PUT URL
  fastify.post<{
    Body: PresignRequest;
    Reply: PresignResponse | ErrorResponse;
  }>('/v1/uploads/presign', {
    schema: {
      body: {
        type: 'object',
        required: ['id', 'contentType', 'sizeBytes'],
        properties: {
          id: { type: 'string', minLength: 1 },
          contentType: { type: 'string', minLength: 1 },
          sizeBytes: { type: 'number', minimum: 0 }
        }
      }
    }
  }, async (request, reply) => {
    try {
      const { id, contentType, sizeBytes } = request.body;

      // Validate ID format
      if (!isValidRecordingId(id)) {
        return reply.code(400).send({
          error: 'Bad Request',
          message: 'Invalid recording ID format',
          statusCode: 400
        });
      }

      // Validate content type
      if (contentType !== 'audio/m4a') {
        return reply.code(400).send({
          error: 'Bad Request', 
          message: 'Content type must be audio/m4a',
          statusCode: 400
        });
      }

      // Validate file size (max 100MB)
      if (sizeBytes > 100 * 1024 * 1024) {
        return reply.code(400).send({
          error: 'Bad Request',
          message: 'File size too large (max 100MB)',
          statusCode: 400
        });
      }

      // Generate presigned URL
      const presignData = await s3.getPresignedPutUrl(id, contentType);
      
      fastify.log.info(`Generated presigned PUT URL for recording: ${id}`);
      
      return reply.code(200).send(presignData);
    } catch (error) {
      fastify.log.error('Presign request failed:', error);
      return reply.code(500).send({
        error: 'Internal Server Error',
        message: 'Failed to generate upload URL',
        statusCode: 500
      });
    }
  });

  // POST /v1/recordings/finalize - Finalize upload and store metadata
  fastify.post<{
    Body: FinalizeRequest;
    Reply: FinalizeResponse | ErrorResponse;
  }>('/v1/recordings/finalize', {
    schema: {
      body: {
        type: 'object',
        required: ['id', 'key', 'title', 'durationSec', 'createdAt'],
        properties: {
          id: { type: 'string', minLength: 1 },
          key: { type: 'string', minLength: 1 },
          title: { type: 'string', minLength: 1, maxLength: 255 },
          durationSec: { type: 'number', minimum: 0 },
          createdAt: { type: 'string' },
          updatedAt: { type: 'string' }
        }
      }
    }
  }, async (request, reply) => {
    try {
      const { id, key, title, durationSec, createdAt, updatedAt } = request.body;

      // Validate ID and key format
      if (!isValidRecordingId(id)) {
        return reply.code(400).send({
          error: 'Bad Request',
          message: 'Invalid recording ID format',
          statusCode: 400
        });
      }

      if (!isValidRecordingKey(key)) {
        return reply.code(400).send({
          error: 'Bad Request',
          message: 'Invalid recording key format',
          statusCode: 400
        });
      }

      // Validate timestamps
      if (!isValidTimestamp(createdAt)) {
        return reply.code(400).send({
          error: 'Bad Request',
          message: 'Invalid createdAt timestamp format',
          statusCode: 400
        });
      }

      if (updatedAt && !isValidTimestamp(updatedAt)) {
        return reply.code(400).send({
          error: 'Bad Request',
          message: 'Invalid updatedAt timestamp format',
          statusCode: 400
        });
      }

      // Store metadata in database
      await db.addRecording({
        id,
        key,
        title,
        durationSec,
        createdAt,
        updatedAt: updatedAt || getCurrentTimestamp()
      });

      fastify.log.info(`Finalized recording: ${id} (${title})`);

      return reply.code(201).send({ id });
    } catch (error) {
      fastify.log.error('Finalize request failed:', error);
      return reply.code(500).send({
        error: 'Internal Server Error',
        message: 'Failed to finalize recording',
        statusCode: 500
      });
    }
  });

  // GET /v1/recordings - List all recordings with signed URLs
  fastify.get<{
    Reply: RecordingResponse[] | ErrorResponse;
  }>('/v1/recordings', async (request, reply) => {
    try {
      const recordings = await db.getAllRecordings();
      
      // Generate signed GET URLs for each recording
      const recordingsWithUrls = await Promise.all(
        recordings.map(async (recording) => {
          try {
            const fileUrl = await s3.getPresignedGetUrl(recording.key);
            return {
              id: recording.id,
              title: recording.title,
              durationSec: recording.durationSec,
              createdAt: recording.createdAt,
              fileUrl
            };
          } catch (error) {
            fastify.log.warn(`Failed to generate URL for recording ${recording.id}:`, error);
            // Return with placeholder URL if signing fails
            return {
              id: recording.id,
              title: recording.title,
              durationSec: recording.durationSec,
              createdAt: recording.createdAt,
              fileUrl: ''
            };
          }
        })
      );

      fastify.log.info(`Listed ${recordings.length} recordings`);
      
      return reply.code(200).send(recordingsWithUrls);
    } catch (error) {
      fastify.log.error('List recordings failed:', error);
      return reply.code(500).send({
        error: 'Internal Server Error',
        message: 'Failed to list recordings',
        statusCode: 500
      });
    }
  });

  // DELETE /v1/recordings/:id - Delete recording and S3 object
  fastify.delete<{
    Params: { id: string };
    Reply: '' | ErrorResponse;
  }>('/v1/recordings/:id', {
    schema: {
      params: {
        type: 'object',
        required: ['id'],
        properties: {
          id: { type: 'string', minLength: 1 }
        }
      }
    }
  }, async (request, reply) => {
    try {
      const { id } = request.params;

      // Get recording metadata first
      const recording = await db.getRecording(id);
      if (!recording) {
        return reply.code(404).send({
          error: 'Not Found',
          message: 'Recording not found',
          statusCode: 404
        });
      }

      // Delete from S3 first
      await s3.deleteObject(recording.key);
      
      // Then delete metadata from database
      const deleted = await db.deleteRecording(id);
      
      if (!deleted) {
        fastify.log.warn(`Recording metadata not found during deletion: ${id}`);
      }

      fastify.log.info(`Deleted recording: ${id}`);
      
      return reply.code(204).send();
    } catch (error) {
      fastify.log.error('Delete recording failed:', error);
      return reply.code(500).send({
        error: 'Internal Server Error',
        message: 'Failed to delete recording',
        statusCode: 500
      });
    }
  });

  // Optional: GET /v1/recordings/:id/stream - Proxy stream for direct playback
  fastify.get<{
    Params: { id: string };
  }>('/v1/recordings/:id/stream', async (request, reply) => {
    try {
      const { id } = request.params;
      
      const recording = await db.getRecording(id);
      if (!recording) {
        return reply.code(404).send({
          error: 'Not Found',
          message: 'Recording not found',
          statusCode: 404
        });
      }

      // Generate a short-lived signed URL and redirect
      const signedUrl = await s3.getPresignedGetUrl(recording.key);
      
      return reply.redirect(302, signedUrl);
    } catch (error) {
      fastify.log.error('Stream recording failed:', error);
      return reply.code(500).send({
        error: 'Internal Server Error',
        message: 'Failed to stream recording',
        statusCode: 500
      });
    }
  });
};

export default recordingsRoutes;